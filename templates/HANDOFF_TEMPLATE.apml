<?xml version="1.0" encoding="UTF-8"?>
<ProjectHandoff version="1.0" date="YYYY-MM-DD">
  <Purpose>
    {HANDOFF_PURPOSE_DESCRIPTION - What is this handoff capturing and why is it important}
  </Purpose>
  
  <ProjectOverview>
    <Name>{PROJECT_NAME}</Name>
    <Framework>{FRAMEWORK_VERSION}</Framework>
    <Status>{CURRENT_STATUS_SUMMARY}</Status>
    <LastMajorMilestone>{LAST_MILESTONE_DATE}: {MILESTONE_DESCRIPTION}</LastMajorMilestone>
    <Architecture>{ARCHITECTURE_DESCRIPTION}</Architecture>
    <DeploymentTarget>{DEPLOYMENT_INFO}</DeploymentTarget>
  </ProjectOverview>
  
  <DevelopmentConstraints>
    <MandatoryReadingComprehension>
      Before making ANY changes, the AI assistant must:
      1. Read and acknowledge understanding of APML Framework v1.4.1 principles from apml_framework_v1.4.1.md
      2. Confirm current project status from registry.apml (especially component status levels and dependencies)
      3. Understand existing architecture patterns and interface contracts from the codebase
      4. Use TodoWrite tool to plan work BEFORE executing any changes
    </MandatoryReadingComprehension>
    
    <ForbiddenActions>
      - Creating mock/placeholder implementations when real components exist in the registry
      - Bulk changes across multiple modules without APML validation
      - Violating existing interface contracts or changing method signatures
      - Adding new dependencies without checking registry patterns and existing architecture
      - Ignoring component status levels (functional/integrated/etc) when making changes
    </ForbiddenActions>
    
    <RequiredValidation>
      <Checkpoint>Must explicitly acknowledge: "I have read the APML framework, understand the current project state from registry.apml, and will make minimal interface-compliant changes following existing architectural patterns"</Checkpoint>
      <BuildValidation>All changes must compile successfully with npm run build</BuildValidation>
      <APMLCompliance>Must respect existing APML status levels and not regress component integration</APMLCompliance>
    </RequiredValidation>
    
    <DocumentationRequirements>
      <MandatoryReads>
        - /README.md for project overview and development workflow
        - /registry.apml for single source of truth on component status and architecture
        - /naming.apml for naming conventions, patterns, and common mistakes
        - /apml_framework_v1.4.2.md for framework principles and constraints
        - This handoff document for current context and priorities
      </MandatoryReads>
      <UpdateRequirements>
        - Update /naming.apml when encountering naming errors or defining new conventions
        - Mark all naming examples as verified="true" only after confirming they work in the codebase
      </UpdateRequirements>
    </DocumentationRequirements>
  </DevelopmentConstraints>
  
  <DocumentLength>
    <Warning>This handoff document is comprehensive and may exceed context limits</Warning>
    <ReadingStrategy>
      <Phase1>Read Purpose, ProjectOverview, and DevelopmentConstraints sections first</Phase1>
      <Phase2>Read CriticalContext section for APML methodology and current issue</Phase2>
      <Phase3>Read NextPrioritySteps for immediate actions</Phase3>
      <Phase4>Reference other sections as needed during implementation</Phase4>
    </ReadingStrategy>
    <KeySections>
      <Essential>Purpose, APMLMethodologySuccess, RecentBreakthrough, NextPrioritySteps</Essential>
      <Reference>RecentChanges, KnownIssues, ArchitecturalDecisions</Reference>
      <Context>DevelopmentEnvironment, HandoffInstructions, FrameworkStatus</Context>
    </KeySections>
  </DocumentLength>

  <CriticalContext>
    <APMLMethodologySuccess>
      <Principle>APML Framework v1.4.2 Systematic Approach Is Essential</Principle>
      <WhyAPMLWorked>
        Traditional debugging focuses on symptoms and attempts quick fixes or workarounds. APML's systematic approach is critical because:
        1. **Interface-First Analysis**: Identifies working vs broken components systematically
        2. **Naming-First Protocol**: 90% rule - check naming/routing before complex architectural investigation  
        3. **Systematic Phase Tracing**: Trace exact execution path instead of guessing
        4. **No-Workaround Principle**: Fix root causes rather than implementing fallbacks
        5. **Documentation-Driven**: Maintain naming.apml and registry.apml to prevent future issues
      </WhyAPMLWorked>
      <AlternativeApproachFailures>
        Without APML systematic approach, typical debugging:
        - Adds more logging instead of fixing condition logic
        - Creates workarounds instead of identifying working systems
        - Focuses on symptoms instead of systematic execution tracing
        - Makes assumptions instead of methodical component verification
      </AlternativeApproachFailures>
      <APMLValidation>This session validates APML's core premise: systematic interface-first analysis with naming protocols eliminates 90% of debugging time and prevents unnecessary architectural complexity</APMLValidation>
    </APMLMethodologySuccess>

    <RecentBreakthrough>
      <Achievement>{MAJOR_ACHIEVEMENT_NAME}</Achievement>
      <Date>{ACHIEVEMENT_DATE}</Date>
      <Impact>{DETAILED_IMPACT_DESCRIPTION}</Impact>
      <ValidationStatus>{VALIDATION_STATUS_SUMMARY}</ValidationStatus>
    </RecentBreakthrough>
    
    <CurrentWorkingFeatures>
      <Feature name="{FEATURE_NAME}" status="{STATUS}">{FEATURE_DESCRIPTION}</Feature>
      <!-- Add more features as needed -->
    </CurrentWorkingFeatures>
  </CriticalContext>
  
  <ProjectState>
    <StatusTrackingSystem>
      <Levels>
        <Level name="not-started" symbol="ðŸ”´" description="Not implemented at all" />
        <Level name="scaffolded" symbol="ðŸŸ¡" description="Basic structure exists but not functional" />
        <Level name="functional" symbol="ðŸŸ " description="Basic functionality works but not polished" />
        <Level name="integrated" symbol="ðŸŸ¢" description="Works with other components properly" />
        <Level name="tested" symbol="ðŸ”µ" description="Has comprehensive tests" />
        <Level name="optimized" symbol="â­" description="Performance optimized and production-ready" />
      </Levels>
    </StatusTrackingSystem>
    
    <ModuleCompletionStatus>
      <Module name="{MODULE_NAME}" status="{STATUS}" completion="{PERCENTAGE}%" priority="{PRIORITY}">{MODULE_DESCRIPTION}</Module>
      <!-- Add all modules -->
    </ModuleCompletionStatus>
  </ProjectState>
  
  <CriticalFiles>
    <SingleSourceOfTruth>
      <File path="{FILE_PATH}" purpose="{FILE_PURPOSE}" criticality="{CRITICALITY_LEVEL}" />
      <!-- Add essential files -->
    </SingleSourceOfTruth>
    
    <CategoryFiles>
      <File path="{FILE_PATH}" purpose="{FILE_PURPOSE}" criticality="{CRITICALITY_LEVEL}" />
      <!-- Add category-specific files -->
    </CategoryFiles>
  </CriticalFiles>
  
  <NextPrioritySteps>
    <HighPriority>
      <Step id="{STEP_ID}" module="{MODULE_NAME}" task="{TASK_NAME}">
        <Description>{TASK_DESCRIPTION}</Description>
        <Context>{TASK_CONTEXT}</Context>
        <ApproachSuggestion>{APPROACH_SUGGESTION}</ApproachSuggestion>
        <ValidationCriteria>{VALIDATION_CRITERIA}</ValidationCriteria>
        <Status>{TASK_STATUS}</Status>
      </Step>
      <!-- Add more high priority steps -->
    </HighPriority>
    
    <MediumPriority>
      <!-- Medium priority steps using same format -->
    </MediumPriority>
    
    <LowPriority>
      <!-- Low priority steps using same format -->
    </LowPriority>
  </NextPrioritySteps>
  
  <RecentChanges>
    <Change date="{CHANGE_DATE}" type="{CHANGE_TYPE}" impact="{IMPACT_LEVEL}">
      <Summary>{CHANGE_SUMMARY}</Summary>
      <Details>
        {DETAILED_CHANGE_DESCRIPTION}
      </Details>
      <ValidationResults>{VALIDATION_RESULTS}</ValidationResults>
    </Change>
    <!-- Add more recent changes -->
  </RecentChanges>
  
  <KnownIssues>
    <Issue severity="{SEVERITY}" module="{MODULE}">
      <Description>{ISSUE_DESCRIPTION}</Description>
      <Impact>{ISSUE_IMPACT}</Impact>
      <Resolution>{RESOLUTION_APPROACH}</Resolution>
    </Issue>
    <!-- Add more known issues -->
  </KnownIssues>
  
  <DevelopmentEnvironment>
    <Setup>
      <Requirement>{REQUIREMENT_DESCRIPTION}</Requirement>
      <!-- Add more requirements -->
    </Setup>
    
    <QuickStart>
      <Command>{COMMAND}</Command>
      <!-- Add more commands -->
      <TestingApproach>{TESTING_APPROACH}</TestingApproach>
      <ValidationInspection>{VALIDATION_INSPECTION}</ValidationInspection>
    </QuickStart>
    
    <KeyTestingScenarios>
      <Scenario name="{SCENARIO_NAME}">
        <Steps>
          {STEP_BY_STEP_INSTRUCTIONS}
        </Steps>
        <ExpectedResult>{EXPECTED_OUTCOME}</ExpectedResult>
      </Scenario>
      <!-- Add more scenarios -->
    </KeyTestingScenarios>
  </DevelopmentEnvironment>
  
  <ArchitecturalDecisions>
    <Decision topic="{DECISION_TOPIC}">
      <Context>{DECISION_CONTEXT}</Context>
      <Resolution>{DECISION_RESOLUTION}</Resolution>
      <Rationale>{DECISION_RATIONALE}</Rationale>
      <Impact>{DECISION_IMPACT}</Impact>
    </Decision>
    <!-- Add more decisions -->
  </ArchitecturalDecisions>
  
  <HandoffInstructions>
    <ImmediateActions>
      <Action priority="{PRIORITY_NUMBER}">{ACTION_DESCRIPTION}</Action>
      <!-- Add more immediate actions -->
    </ImmediateActions>
    
    <ContextBoundaries>
      <Boundary name="{BOUNDARY_NAME}">{BOUNDARY_DESCRIPTION}</Boundary>
      <!-- Add more boundaries -->
    </ContextBoundaries>
    
    <CommunicationGuidelines>
      <Guideline>{GUIDELINE_DESCRIPTION}</Guideline>
      <!-- Add more guidelines -->
    </CommunicationGuidelines>
  </HandoffInstructions>
  
  <FrameworkStatus>
    <ComponentStatus>
      <Component name="{COMPONENT_NAME}" status="{STATUS}" description="{DESCRIPTION}">
        <Coverage>{COVERAGE_INFO}</Coverage>
        <ExecutionType>{EXECUTION_TYPE}</ExecutionType>
        <Priority>{PRIORITY_INFO}</Priority>
      </Component>
      <!-- Add more components -->
    </ComponentStatus>
    
    <SystemStatus>
      <System>{SYSTEM_DESCRIPTION}</System>
      <!-- Add more systems -->
    </SystemStatus>
  </FrameworkStatus>
</ProjectHandoff>